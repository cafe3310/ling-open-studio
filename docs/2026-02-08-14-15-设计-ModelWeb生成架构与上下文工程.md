# 设计：Model Web 生成架构与上下文工程 (v2)

## 1. 背景与目标 (v2)

本设计文档旨在重新定义 Model Web 的生成逻辑。基于用户反馈，我们采用了更稳健的 **双 Graph 架构**，并引入了 **“样本驱动 (Example-Driven)”** 的上下文工程策略，以确保模型在特定技术栈（HTML/Tailwind, React）下能生成可运行、高质量的代码。

## 2. 核心架构：双 Graph 策略

我们将生成过程拆分为两个独立的 LangGraph：

### 2.1 Graph 1: Initial Generation (从零构建)
当用户首次发起请求（或明确要求重新开始）时触发。
**流程**: `User Input` -> `Idea Expander` -> `Style Director` -> `Code Generator` -> `End`

### 2.2 Graph 2: Refinement (迭代修改)
当当前 Session 已有生成的网页，且用户提出修改意见时触发。
**流程**: `User Feedback` -> `Editor` -> `End`

---

## 3. 详细节点设计与上下文工程

🟥 列出所有的输入：用户prompt；设计选项的选择；技术栈的选择。

🟥 type 设计选项的选择 = { 显示的名字，显示的图标，给模型的描述（整体），给模型的描述（色彩），给模型的描述（样式），给模型的描述（字体） }
🟥 type 技术栈的选择 = { 显示的名字，给设计风格的描述，给充实方案的描述 }


### 节点 A: 设计风格 (Style Director)
- **职责**: 根据需求和用户选择的风格（或默认），制定详细的视觉规范。
- **输入**: 需求描述 (From Node A)
- **Context 注入**: `Aesthetic Definitions` (美学定义库)。
- **System Prompt 重点**:
    - 角色：视觉总监。
    - 目标：输出具体的配色方案（Hex Codes）、字体选择（Google Fonts URL）、圆角/间距规范。
    - **关键**: 必须输出符合 Tailwind 规范的类名建议（如 `rounded-xl`, `gap-8`, `bg-stone-50`）。
- **输出**: Visual Design Spec (JSON/Markdown)。

🟥 输入的例子和生成上下文的例子。这个节点输入 (节点A提示模板) +（type 设计选项).给模型的描述(所有) + (用户 prompt) + (type 技术栈).给设计风格的描述   ，输出 节点a输出 = {设计色表，样式合集，字体合集，布局建议}

### 节点 B: 充实方案 (Idea Expander)
- **职责**: 将用户简短的 prompt（如“做一个咖啡店主页”）扩展为详细的产品需求文档。
- **输入**: User Prompt
- **Context 注入**: 无需特定技术栈。
- **System Prompt 重点**:
  - 角色：产品经理。
  - 目标：分析用户意图，补全页面结构（Header, Hero, Features, Footer）、文案风格和功能点。
- **输出**: 结构化的需求描述 (Markdown)。

🟥 输入的例子和生成上下文的例子。这个节点输入 (节点B提示模板) + (用户 prompt) + (type 技术栈).给充实方案的描述 ， 输出  节点b输出 = {页面整体结构，页面每个部分都是什么，用什么库写，内容是什么}


### 节点 C: 具体生成 (Code Generator)
- **职责**: 综合需求和视觉规范，编写可执行代码。
- **输入**: 需求 + 视觉规范
- **Context 注入**: **Tech Stack Boilerplates (关键)**
- **System Prompt 重点**:
  - 角色：高级前端工程师。
  - **样本增强 (Few-Shot)**: 必须包含目标技术栈的完整 `index.html` 骨架。

🟥 输入的例子和生成上下文的例子。这个节点输入 {节点C提示模板， 用户 prompt， 节点A输出，节点B输出, vfs工具描述}， 输出 {包含工具调用的代码文件内容}
  
  #### 示例：HTML + Tailwind 上下文模板
  ```markdown
  You are an expert web developer.
  
  ## TECH STACK RULES
  1. Use HTML5.
  2. Use Tailwind CSS via CDN: <script src="https://cdn.tailwindcss.com"></script>
  3. Use Lucide Icons via CDN: <script src="https://unpkg.com/lucide@latest"></script>
  4. Initialize Icons: Add <script>lucide.createIcons();</script> at the end of body.
  
  ## BOILERPLATE (Follow this structure EXACTLY)
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <script src="https://cdn.tailwindcss.com"></script>
      <script src="https://unpkg.com/lucide@latest"></script>
      <link href="[FONT_URL_FROM_STYLE_DIRECTOR]" rel="stylesheet">
      <style>
        body { font-family: '[FONT_NAME]', sans-serif; }
      </style>
  </head>
  <body class="[BG_COLOR_FROM_STYLE] [TEXT_COLOR_FROM_STYLE]">
      <!-- Your Content Here -->
      <script>
        lucide.createIcons();
      </script>
  </body>
  </html>
  ```
- **输出**: 工具调用 `write_file(path, content)`。

### 节点 D: 处理问题并识别 (Editor)
- **职责**: 读取现有代码，根据反馈进行修改。
- **输入**: User Feedback + Chat History
- **Context 注入**:
  - **VFS State**: 当前文件列表 (`list_directory` 结果)。
  - **Tech Stack Rules**: 简化的规则提醒（不要破坏现有的 CDN 引入）。
- **System Prompt 重点**:
  - 角色：维护工程师。
  - 策略：先 `read_file` 读取目标文件，修改后 `write_file` 覆盖。
  - 注意：对于 HTML 单文件，通常需要全量重写以保证完整性（除非使用 diff patch 工具，但目前我们用全量覆盖更稳妥）。

🟥 输入的例子和生成上下文的例子。这个节点输入 {D 系统提示模板，当前生成的文件列表，vfs 工具描述，用户指令，报错信息列表}， 输出 节点D输出 = {要读取的文件内容} 。

### 节点 E：解决问题

类似

🟥 这个节点输入 {E 系统提示模板，当前生成的文件列表，vfs 工具描述，用户指令，节点 D 输出}，输出 节点E输出 = {含编辑操作的vsf 指令}

---

## 4. Graph 路由逻辑 (Router)

我们需要一个简单的路由逻辑来决定使用哪个 Graph：

- **Initial Gen**: 如果 `vfs.list_directory("/")` 为空，或用户显式发送 `/reset`, `/new` 等指令。
- **Refinement**: 如果 `index.html` 存在，且用户输入非重置指令。

*(注：在 LangGraph 中，可以通过检查 State 中的 `is_initialized` 标记来实现)*

## 5. 技术栈样本库 (Boilerplate Library)

我们将预定义以下几种技术栈的样本，存储在 `lib/boilerplates/` 中：

1.  **HTML + Tailwind (Default)**: 最轻量，适合静态展示。
2.  **React (CDN) + Tailwind**: 适合需要交互的组件。
    - *关键点*: 使用 Babel Standalone 编译 JSX。
    - *示例*:
      ```html
      <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
      <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
      <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
      <script type="text/babel">
        // React Code Here
      </script>
      ```

## 6. 下一步行动

1.  **创建 Boilerplate 模块**: 实现 `lib/boilerplates/index.ts`。
2.  **实现 Initial Gen Graph**:
    - 定义 `State` (包含 requirement, style_spec)。
    - 实现 3 个节点的逻辑。
3.  **实现 Refinement Graph**:
    - 定义单节点 Loop。
4.  **UI 集成**: 在 `WebTab` 中根据 VFS 状态自动路由。
