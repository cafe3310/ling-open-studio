# 技术选型决策：混合架构方案 (Hybrid Architecture)

## 1. 决策背景
在规划新演示项目时，我们面临两种技术路径的选择：
1.  **路径 A (OSW Studio 原生)**：复用 `osw-studio` 的 Next.js Standalone + 原生 Fetch 架构。
2.  **路径 B (Assistant UI + LangGraph)**：参考 `ling-model-judge`，使用 AI SDK + Assistant UI + LangGraph。

**核心需求回顾**：
-   需要实现 Chat, Web (Code Gen), Write (Assistant) 三大功能模块。
-   **关键约束**：明确要求在后端使用 **LangGraph** 来编排多模型工作流（特别是在 Writer 模块的后台分析任务中）。
-   需要复用 `osw-studio` 优秀的 Monaco Editor 和 Preview 组件。

## 2. 深度对比分析

| 维度 | OSW Studio (原生) | Assistant UI + LangGraph |
| :--- | :--- | :--- |
| **API 对接** | 原生 `fetch`，手写流解析器。控制力强，但维护成本高。 | 封装良好的 `useChatRuntime` + `LangChainAdapter`。开箱即用，协议标准。 |
| **工作流编排** | 无内置编排引擎。需手写状态机。 | **LangGraph 原生支持**。完美契合“后台分析”、“多步生成”等复杂逻辑。 |
| **上下文管理** | 简单的 `LLMMessage[]` 数组。 | 完整的 `Thread` 状态管理，支持附件、分支、编辑历史。 |
| **Chat UI** | 自定义 React 组件。需自行维护滚动、Markdown 渲染、代码高亮。 | **Assistant UI** 组件库。内置了高质量的 Chat 体验（Markdown, Attachments, Optimistic Updates）。 |
| **定制灵活性** | 极高。完全掌控 DOM 结构。 | 较高。通过 `ComponentsProvider` 可以替换大部分 UI，但布局（Layout）需要一定的技巧来定制。 |

## 3. 最终决策：混合架构 (The Hybrid Approach)

我们决定采用 **"Assistant UI 的脑 + OSW Studio 的脸 + LangGraph 的心"** 的混合架构。

### 3.1 架构蓝图

```mermaid
graph TD
    User[用户] --> Frontend[Next.js App Router]
    
    subgraph Frontend_Layer [前端层 (Assistant UI + Custom Layout)]
        AU_Runtime[Assistant UI Runtime] --> Custom_Layout[自定义三栏布局]
        Custom_Layout --> Chat[Chat Sidebar (Assistant UI)]
        Custom_Layout --> Editor[Monaco Editor (移植自 OSW)]
        Custom_Layout --> Preview[Preview Frame (移植自 OSW)]
    end
    
    Frontend -->|POST /api/graph/:id| Backend[Next.js API Route]
    
    subgraph Backend_Layer [后端层 (LangGraph)]
        Backend --> LangGraph_Node[LangGraph 节点]
        LangGraph_Node -->|State Update| State[Graph State]
        LangGraph_Node -->|LLM Call| Model[Model API (OpenAI Compatible)]
    end
```

### 3.2 实施细节

1.  **前端框架 (Base)**：
    -   初始化一个新的 Next.js 项目（或重构现有 App 目录），引入 `@assistant-ui/react` 和 `@assistant-ui/react-ai-sdk`。
    -   使用 `InclusionAI` 风格（Tailwind）重写全局 Layout。

2.  **AI 通信层 (Transport)**：
    -   使用 `AssistantChatTransport` 对接 `/api/graph/[graphId]`。
    -   前端通过 `useAssistant(runtime)` 获取消息流，并根据消息内容（如 Tool Call 或特定 Artifact）驱动右侧的 Editor 和 Preview 更新。

3.  **工作流编排 (Workflow)**：
    -   在后端定义三个 LangGraph 图：
        -   `chat-graph`: 基础对话。
        -   `web-graph`: 生成代码 -> 写入 Artifact -> 返回预览 URL。
        -   `write-graph`: 接收文本 -> 后台提取实体 -> 生成灵感建议 -> 推送给前端。

4.  **组件移植 (Migration)**：
    -   将 `osw-studio/components/editor` (Monaco) 移植进来，剥离 VFS 依赖，改为受控组件 (Controlled Component)。
    -   将 `osw-studio/components/preview` 移植进来，支持 iframe 渲染。

## 4. 预期收益
-   **开发效率**：LangGraph 解决了后端复杂逻辑的编排问题；Assistant UI 解决了前端 Chat 交互的繁琐细节。
-   **体验升级**：支持流式组件渲染（StreamUI），可以在 Chat 过程中实时流出 UI 组件（如灵感卡片）。
-   **可维护性**：前后端解耦，AI 逻辑完全收敛在 LangGraph 中，前端专注于展示。
