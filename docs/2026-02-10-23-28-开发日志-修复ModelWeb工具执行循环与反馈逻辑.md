# 2026-02-10-23-28-开发日志-修复ModelWeb工具执行循环与反馈逻辑

## 1. 背景 (Background)

在上一阶段实现 Model Web 工具自动化后，引入了两个严重 Bug：
1. **工具执行死循环**：在 `silent` 模式下，工具被反复触发调用（如 `write_file` 不断写入）。
2. **多余补全请求**：工具执行后触发了不必要的下一次助手轮次，导致界面出现重复或无意义的文本块。

## 2. 来源文档 (Source)
- [[2026-02-10-23-18-开发日志-ModelWeb工具自动化与多阶段状态UI实现]]

## 3. 主要工作 (Major Changes)

### 3.1 修复工具执行死循环
- **本地执行缓存 (`localExecutionCache`)**：在 `ToolCallRenderer.tsx` 中引入了基于 `messageId` 的本地执行缓存。
    - **原理**：由于 `silent` 模式不向线程追加结果消息，`isAlreadyExecuted` 无法通过线程历史判断。本地缓存确保了即使不追加消息，组件也能记住该工具已执行。
- **状态同步逻辑修正**：移除了 `React.useEffect` 中将 `success` 状态强制重置为 `idle` 的逻辑。
    - **修复原因**：之前的逻辑在 `silent` 模式下（因为查不到历史结果）会不断把状态设回 `idle`，从而导致自动执行逻辑反复触发。

### 3.2 修复多余补全请求
- **恢复 `silent` 判定**：在 `ToolCallRenderer` 的 `handleExecute` 中恢复了对 `silent` 属性的检查。
    - **效果**：在 `WebArchitect` 场景下（`silent={true}`），工具执行后不再调用 `aui.thread().append`，从而彻底切断了自动触发下一次 Assistant Turn 的路径。

### 3.3 UI 鲁棒性增强
- **增强 `WebMarkdownText` 过滤**：除了过滤工具调用块 (`=== write_file ===`)，现在还会自动剔除消息中可能残留的工具结果块 (`=== tool_result ===`)，确保界面只展示纯净的说明文字。

## 4. 遇到的问题与修正 (Issues & Fixes)

- **状态竞争与循环**：
    - **问题**：`isAlreadyExecuted` 依赖 `threadMessages`，而 `silent` 模式不更新 `threadMessages`。
    - **修正**：使用模块级别的 `Set` 作为 `localExecutionCache`。虽然简单，但在当前单页应用会话中足以解决状态丢失问题。

## 5. 后续计划 (Next Steps)

- [ ] 继续观察复杂多轮对话下的自动化稳定性。
- [ ] 开始 **Model Write** 助手的实现。
