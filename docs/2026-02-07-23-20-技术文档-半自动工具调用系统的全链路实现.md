# 2026-02-07-23-20-技术文档-半自动工具调用系统的全链路实现

## 1. 架构概览 (Architecture Overview)

本项目实现了一套“半自动、用户介导”的工具调用系统。其核心设计理念是：将工具调用的执行权交还给用户，并将执行结果通过标准对话历史回填给模型。

### 核心组件：
- **后端策略层 (`ToolContextDef`)**: 定义工具在提示词中的表现形式及解析规则。
- **动态注入层 (`ToolContextBuilder`)**: 根据用户配置实时生成增强后的 System Prompt。
- **客户端执行层 (`client-executor.ts`)**: 在浏览器沙箱内安全执行 JS 或 VFS 操作。
- **消息拦截层 (`ToolCallRenderer`)**: 在 `assistant-ui` 的消息流结束后进行协议扫描并渲染交互 UI。

---

## 2. 协议设计与策略 (Protocols & Strategies)

为了适配不同能力的模型，我们抽象了 `ToolContextDef` 接口，支持多种范式：

### 2.1 JSON_Strict (默认策略)
针对 GPT-4o, Llama 3 等模型，强制要求输出标准的 `tool_calls` JSON 对象。
- **调用特征**: 包含 `tool_calls` 关键字的 JSON 块。
- **优势**: 结构化程度高，易于机器解析。

### 2.2 XML_Tag (推理模型优化)
针对 Claude 或 DeepSeek R1 等对标签敏感的模型，使用 `<tool_code>` 包裹调用。
- **结构**: `<tool_code> { "name": "...", "arguments": {...} } </tool_code>`。
- **优势**: 能够有效隔离思考过程（Thought）与工具指令。

---

## 3. 全链路流转细节 (Data Flow)

### 3.1 后端注入 (Server-Side Injection)
在 `app/api/chat/route.ts` 中，我们动态拦截请求并修改消息列表：
1. 从 `config` 中读取 `enabledTools` 和 `toolParadigm`。
2. 调用 `strategy.spliceSystemPrompt` 生成增强提示词。
3. 将增强提示词更新到 `SystemMessage` 中。

### 3.2 客户端拦截 (Client-Side Interception)
我们在 `AssistantMessage` 组件内部挂载了 `ToolCallRenderer`。
- **触发时机**: 监听 `useMessage()` 的状态。仅在 `status.type === 'complete'` 且 `role === 'assistant'` 时触发。
- **解析逻辑**: 使用当前策略的 `parseResponse` 对消息全文进行正则匹配和 JSON 解析。

### 3.3 执行与回填 (Execution & Feedback)
1. **用户点击**: 触发 `handleExecute`。
2. **执行**: `clientTools` 执行具体的浏览器 API 调用（如 `window.eval` 或 `vfs.writeFile`）。
3. **回填**: 执行结果被格式化为“伪装的 User 消息”：
   ```json
   {
     "tool_call_result": {
       "toolCallId": "call_123",
       "result": "..."
     }
   }
   ```
4. **循环**: 调用 `runtime.append({ role: "user", content: ... })`。这会触发一次新的 API 请求，模型在上下文中看到结果后继续回答。

---

## 4. 技术经验与陷阱 (Technical Notes & Pitfalls)

### 4.1 useMessage 的正确姿势
在 `assistant-ui` 中，`useMessage()` 返回的不是包含消息的对象，而是 **消息对象本身**。
- **错误用法**: `useMessage((s) => s.message)` -> 得到 `undefined`。
- **正确用法**: `const message = useMessage()` -> 直接访问 `message.content`, `message.role`。

### 4.2 消息解析的完整性
最初尝试在 Token 流动时进行解析（hasToolCall），但这会导致不完整的 JSON 块导致解析器崩溃。
**最终方案**: 必须等待消息完全停止生成后再进行一次性解析，以确保 JSON/XML 结构的完整性。

### 4.3 XML 协议中的代码转义
虽然尝试了纯 XML 结构，但由于 `write_file` 涉及大量代码字符，最终决定采用 **XML 标签内嵌 JSON Payload** 的折中方案，利用 JSON 的成熟转义机制避免 XML 结构被代码内容破坏。

---

## 5. 已实现工具集 (Implemented Toolsets)

| 工具名 | 用途 | 参数 |
| :--- | :--- | :--- |
| `browser_js_eval` | 执行浏览器 JS | `code` (string) |
| `list_directory` | 列出 VFS 目录 | `path` (string) |
| `read_file` | 读取 VFS 文件 | `path` (string) |
| `write_file` | 写入 VFS 文件 | `path`, `content` |
