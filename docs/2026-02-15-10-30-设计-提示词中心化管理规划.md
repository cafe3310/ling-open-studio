# 提示词中心化管理规划 (Prompt Centralization Plan)

## 1. 背景与目标 (Background & Goals)
当前项目中，提示词（Prompts）和提示词拼接逻辑（Stitching Logic）分布在多个位置：
- 部分硬编码在 LangGraph 节点的 `graph.ts` 或 `initial-gen.ts` 中。
- 部分存在于 `assistants/web-architect/prompts/` 目录下。
- 拼接工具定义的逻辑耦合在 `lib/tools/ctx-*.ts` 中。

**目标**：
1. **中心化存储**：将所有提示词片段、模板和配置移动到统一的 `src/lib/prompts/` 目录。
2. **逻辑解耦**：将拼接（Splicing/Stitching）逻辑移动到 `src/lib/prompt-engine/`。
3. **一致性**：确保不同助手使用的通用指令（如工具使用规范、视觉风格定义）保持一致。
4. **易维护性**：方便提示词工程师在不修改业务逻辑代码的情况下优化模型表现。

## 2. 目录结构设计 (Proposed Structure)

### 2.1 提示词库 (`src/lib/prompts/`)
```text
src/lib/prompts/
├── shared/                 # 通用片段，跨助手复用
│   ├── constraints.ts      # 基础约束（语言、格式、礼貌等）
│   ├── ui-guidelines.ts    # UI 相关（Lucide 图标、Tailwind 类使用规范）
│   └── tools-protocol.ts   # 工具调用协议的文本描述
├── assistants/             # 助手特定提示词
│   ├── general-chat/
│   │   └── system.ts
│   ├── naming/
│   │   └── summarizer.ts   # 对应当前的 naming graph 提示词
│   ├── web-architect/      # 从原位置迁移
│   │   ├── idea-expander.ts
│   │   ├── style-director.ts
│   │   ├── code-generator.ts
│   │   └── data/           # 视觉风格、技术栈等静态定义
│   │       ├── designs.ts
│   │       └── tech-stacks.ts
│   └── write-architect/
│       └── creative.ts
└── index.ts                # 统一导出
```

### 2.2 提示词引擎 (`src/lib/prompt-engine/`)
```text
src/lib/prompt-engine/
├── stitchers/              # 拼接策略（原 lib/tools/ctx-*.ts 的部分逻辑）
│   ├── delimited.ts        # 处理分隔符格式的拼接
│   ├── json.ts             # 处理 JSON 格式的拼接
│   └── xml.ts              # 处理 XML 格式的拼接
├── builder.ts              # 核心构建器，负责组装 Base + Shared + Tools
└── index.ts                # 公开接口
```

## 3. 重构路径 (Refactoring Path)

### 步骤 1：建立新目录并迁移片段
- 创建 `src/lib/prompts/` 及其子目录。
- 提取 `web-architect` 中的 `designs.ts` 和 `tech-stacks.ts` 到新位置。
- 提取 `ToolCtxDelimited` 等中的文本片段到 `shared/tools-protocol.ts`。

### 步骤 2：迁移助手提示词
- 将 `naming/graph.ts` 中的硬编码字符串迁移至 `prompts/assistants/naming/summarizer.ts`。
- 将 `web-architect/initial-gen.ts` 中的三个模板迁移至对应文件。

### 步骤 3：重构拼接逻辑
- 在 `prompt-engine` 中重新实现拼接逻辑，使其不再依赖具体的工具实例，而是接受工具定义列表作为输入。
- 修改 `api/chat` 和各 `graph.ts`，调用新的 `prompt-engine` 构建完整提示词。

### 步骤 4：清理与验证
- 移除各处的冗余提示词定义。
- 运行构建并验证各助手功能是否正常。

## 4. 后续收益
- **多模型适配**：可以针对不同模型（如 Ling, Ring, Flash）提供优化的提示词版本。
- **国际化**：更容易支持多语言的系统提示词切换。
- **可测试性**：可以独立于应用逻辑对提示词片段进行单元测试或评估。
