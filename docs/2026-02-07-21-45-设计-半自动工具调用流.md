# 2026-02-07-21-45-设计-半自动工具调用流 (User-Mediated Tool Loop)

## 1. 方案概述

本方案设计了一种“半自动、用户介导”的工具调用闭环。与全自动循环不同，它通过 UI 显式展示工具意图，并由用户通过点击按钮触发执行。执行结果以**伪装成 User 消息**的形式回填给服务端 Agent。

这种方案的优点：
1.  **安全性**: 用户对高危操作（如写文件、执行 JS）有最终决定权。
2.  **兼容性**: 不依赖模型复杂的原生 Tool Result 处理，仅需模型能理解对话历史中的 JSON。
3.  **调试友好**: 所有的工具调用参数和结果在聊天历史中可见。

## 2. 完整时序与上下文流转

场景：用户要求计算 1000 以内的素数之和。

### 步骤 1: 用户发起请求 (User -> Server)

**Request POST `/api/chat`**:
```json
{
  "messages": [
    { "role": "user", "content": "计算 1000 以内的所有素数之和。" }
  ],
  "config": { "mode": "chat", "model": "ling-1t" }
}
```

### 步骤 2: 服务端构造上下文并请求模型 (Server -> Model)

服务端注入 `TOOL_PROTOCOL` 提示词。

**Model Input (Prompt)**:
```markdown
=== SYSTEM ===
### TOOL_PROTOCOL: Browser Execution
You can execute JavaScript in the user's browser.
- TOOL: `browser_js_eval(code: string)`
... (protocol details) ...

=== USER ===
计算 1000 以内的所有素数之和。
```

### 步骤 3: 模型生成工具调用意图 (Model -> Server -> Client)

模型决定使用工具，并在消息中输出特定的 JSON 块。

**Model Output / API Response**:
```markdown
我将使用浏览器执行工具来计算 1000 以内的所有素数之和。

{
  "tool_calls": [
    {
      "id": "call_1",
      "type": "function",
      "function": {
        "name": "browser_js_eval",
        "arguments": "{\"code\": \"(function sumPrimes(limit) { ... })(1000);\"}"
      }
    }
  ]
}
```

### 步骤 4: 客户端拦截并渲染 UI (Client Side)

`assistant-ui` 检测到消息中的 `tool_calls` JSON 块：
1.  渲染一段文字：“正在生成工具调用...”。
2.  展示代码预览块。
3.  **渲染按钮**：`[ 执行此 Tool Call ]`。

### 步骤 5: 用户触发执行 (User Interaction -> Client Execution)

用户点击按钮：
1.  客户端执行 `eval("(function sumPrimes...)(1000)")`。
2.  得到结果 `76127`。

### 步骤 6: 结果回填并再次请求 (Client -> Server)

客户端构造一条特殊的 **User 消息** 发送回服务端，代表工具执行结果。

**Request POST `/api/chat` (Session Updated)**:
```json
{
  "messages": [
    { "role": "user", "content": "计算 1000 以内的所有素数之和。" },
    { "role": "assistant", "content": "我将使用浏览器执行工具... { \"tool_calls\": [...] }" },
    {
      "role": "user",
      "content": "{\n   \"tool_call_result\": {\n      \"toolCallId\": \"call_1\",\n      \"result\": 76127\n   }\n}"
    }
  ]
}
```

### 步骤 7: 服务端处理并生成最终答案 (Server -> Model -> Client)

服务端将这组消息发送给模型。模型看到 User 提供了它之前要求的 `call_1` 的结果。

**Model Input (Context Update)**:
```markdown
... (Previous Context) ...
=== ASSISTANT ===
我将使用浏览器执行工具... { "tool_calls": [{"id": "call_1", ...}] }

=== USER ===
{
   "tool_call_result": {
      "toolCallId": "call_1",
      "result": 76127
   }
}
```

**Final Model Output**:
```markdown
计算完成。1000 以内的所有素数之和为 76127。
```

## 3. 关键实现细节

### 3.1 客户端拦截逻辑
我们需要在 `Assistant` 组件中自定义 `MessageContent` 渲染器。当检测到内容符合 JSON 格式且包含 `tool_calls` 键时，切换到工具调用预览模式。

### 3.2 服务端识别逻辑
服务端无需特殊处理 `tool_call_result`，因为它被作为普通消息处理。但为了优化，我们可以在 `Prompt-Reinforced` 协议中加入一句话：
> "When a tool result is provided by the user in the format `{\"tool_call_result\": ...}`, treat it as the successful output of your previous tool request."

### 3.3 异步性说明
在这种模式下，**没有全自动的 Server-Side Loop**。模型每输出一个工具调用，HTTP 请求就结束了。下一次请求（带结果）是一个全新的请求，通过 `messages` 数组维持状态。

## 4. Tool Call 配置 (Tool Call Configuration)

为了适配不同模型的“脾气”，我们将配置抽象为 **Prompt Strategy Profile**。以下定义了两种典型 Profile：`JSON_Strict`（适用于 GPT-4, Llama 3 等现代模型）和 `XML_Tag`（适用于 Claude, Mistral 等对 Tag 敏感的模型）。

### Profile A: JSON_Strict (Default)

**适用场景**: 通用能力较强，对 JSON 结构理解良好的模型。

#### 1. Tool Call 描述提示词 (Protocol Introduction)
*(插入 System Prompt 顶部)*
```markdown
### TOOL_USE_PROTOCOL
You have access to a set of client-side tools. To use a tool, you must output a JSON object strictly following the `tool_calls` schema defined below.
- **Trigger**: When you need external data or action, output the JSON immediately.
- **Constraints**: 
  - Do NOT wrap the JSON in markdown code blocks (like ```json).
  - The JSON must be valid and parsable.
  - You can invoke multiple tools in one `tool_calls` array if needed.
```

#### 2. Tool Call 定义提示词 (Schema Definition)
*(为每个工具生成，追加在 Protocol 后)*
```markdown
#### Available Tool: {tool_name}
- **Description**: {description}
- **Schema**:
  {
    "type": "function",
    "function": {
      "name": "{tool_name}",
      "parameters": {json_schema_of_parameters}
    }
  }
```

#### 3. Tool Call 调用模板 (Call Template)
*(模型输出格式)*
```json
{
  "tool_calls": [
    {
      "id": "call_{unique_id}",
      "type": "function",
      "function": {
        "name": "{tool_name}",
        "arguments": "{json_string_of_arguments}"
      }
    }
  ]
}
```

#### 4. Tool Call 结果模板 (Result Template)
*(用户回填格式)*
```json
{
  "tool_call_result": {
    "toolCallId": "call_{unique_id}",
    "result": {raw_result_value}
  }
}
```

---

### Profile B: XML_Tag (Reasoning/Legacy)

**适用场景**: 对结构化 JSON 生成不稳定的推理模型，或倾向于 XML 标签的模型（如 DeepSeek R1, Claude）。

#### 1. Tool Call 描述提示词 (Protocol Introduction)
```markdown
### TOOL_USE_PROTOCOL
You can invoke tools by wrapping your request in `<tool_code>` tags.
- **Workflow**:
  1. Think about the parameters needed.
  2. Output `<tool_code>` containing the tool name and parameters.
  3. Stop generating and wait for the user to provide `<tool_result>`.
```

#### 2. Tool Call 定义提示词 (Schema Definition)
```markdown
#### Tool: {tool_name}
- **Description**: {description}
- **Usage Format**:
  <tool_code>
  {tool_name}({param1}="value", {param2}="value")
  </tool_code>
```

#### 3. Tool Call 调用模板 (Call Template)
```xml
<tool_code>
{tool_name}(code="(function()...)()", path="/src/app.tsx")
</tool_code>
```
*(注意：参数格式可能需要更严格的定义，或者在 XML 内部依然使用 JSON)*

**修正版 (XML + JSON Payload)**:
```xml
<tool_code>
{
  "name": "{tool_name}",
  "arguments": {json_object}
}
</tool_code>
```

#### 4. Tool Call 结果模板 (Result Template)
```xml
<tool_result>
  <id>{tool_name}_result</id>
  <content>
    {raw_result_value}
  </content>
</tool_result>
```

---

### 5. 实现建议

在代码实现中，建立 `ToolContextBuilder` 类，接受 `Profile` 参数。

```typescript
type ProfileType = 'JSON_Strict' | 'XML_Tag';

interface ToolConfig {
  intro: string;
  definitionTemplate: (tool: Tool) => string;
  resultTemplate: (id: string, result: any) => string;
}

const profiles: Record<ProfileType, ToolConfig> = {
  JSON_Strict: { ... },
  XML_Tag: { ... }
};
```
