# 2026-02-07-21-45-设计-半自动工具调用流 (User-Mediated Tool Loop)

## 1. 方案概述

本方案设计了一种“半自动、用户介导”的工具调用闭环。与全自动循环不同，它通过 UI 显式展示工具意图，并由用户通过点击按钮触发执行。执行结果以**伪装成 User 消息**的形式回填给服务端 Agent。

这种方案的优点：
1.  **安全性**: 用户对高危操作（如写文件、执行 JS）有最终决定权。
2.  **兼容性**: 不依赖模型复杂的原生 Tool Result 处理，仅需模型能理解对话历史中的 JSON。
3.  **调试友好**: 所有的工具调用参数和结果在聊天历史中可见。

## 2. 完整时序与上下文流转

场景：用户要求计算 1000 以内的素数之和。

### 步骤 1: 用户发起请求 (User -> Server)

**Request POST `/api/chat`**:
```json
{
  "messages": [
    { "role": "user", "content": "计算 1000 以内的所有素数之和。" }
  ],
  "config": { "mode": "chat", "model": "ling-1t" }
}
```

### 步骤 2: 服务端构造上下文并请求模型 (Server -> Model)

服务端注入 `TOOL_PROTOCOL` 提示词。

**Model Input (Prompt)**:
```markdown
=== SYSTEM ===
### TOOL_PROTOCOL: Browser Execution
You can execute JavaScript in the user's browser.
- TOOL: `browser_js_eval(code: string)`
... (protocol details) ...

=== USER ===
计算 1000 以内的所有素数之和。
```

### 步骤 3: 模型生成工具调用意图 (Model -> Server -> Client)

模型决定使用工具，并在消息中输出特定的 JSON 块。

**Model Output / API Response**:
```markdown
我将使用浏览器执行工具来计算 1000 以内的所有素数之和。

{
  "tool_calls": [
    {
      "id": "call_1",
      "type": "function",
      "function": {
        "name": "browser_js_eval",
        "arguments": "{\"code\": \"(function sumPrimes(limit) { ... })(1000);\"}"
      }
    }
  ]
}
```

### 步骤 4: 客户端拦截并渲染 UI (Client Side)

`assistant-ui` 检测到消息中的 `tool_calls` JSON 块：
1.  渲染一段文字：“正在生成工具调用...”。
2.  展示代码预览块。
3.  **渲染按钮**：`[ 执行此 Tool Call ]`。

### 步骤 5: 用户触发执行 (User Interaction -> Client Execution)

用户点击按钮：
1.  客户端执行 `eval("(function sumPrimes...)(1000)")`。
2.  得到结果 `76127`。

### 步骤 6: 结果回填并再次请求 (Client -> Server)

客户端构造一条特殊的 **User 消息** 发送回服务端，代表工具执行结果。

**Request POST `/api/chat` (Session Updated)**:
```json
{
  "messages": [
    { "role": "user", "content": "计算 1000 以内的所有素数之和。" },
    { "role": "assistant", "content": "我将使用浏览器执行工具... { \"tool_calls\": [...] }" },
    {
      "role": "user",
      "content": "{\n   \"tool_call_result\": {\n      \"toolCallId\": \"call_1\",\n      \"result\": 76127\n   }\n}"
    }
  ]
}
```

### 步骤 7: 服务端处理并生成最终答案 (Server -> Model -> Client)

服务端将这组消息发送给模型。模型看到 User 提供了它之前要求的 `call_1` 的结果。

**Model Input (Context Update)**:
```markdown
... (Previous Context) ...
=== ASSISTANT ===
我将使用浏览器执行工具... { "tool_calls": [{"id": "call_1", ...}] }

=== USER ===
{
   "tool_call_result": {
      "toolCallId": "call_1",
      "result": 76127
   }
}
```

**Final Model Output**:
```markdown
计算完成。1000 以内的所有素数之和为 76127。
```

## 3. 关键实现细节

### 3.1 客户端拦截逻辑
我们需要在 `Assistant` 组件中自定义 `MessageContent` 渲染器。当检测到内容符合 JSON 格式且包含 `tool_calls` 键时，切换到工具调用预览模式。

### 3.2 服务端识别逻辑
服务端无需特殊处理 `tool_call_result`，因为它被作为普通消息处理。但为了优化，我们可以在 `Prompt-Reinforced` 协议中加入一句话：
> "When a tool result is provided by the user in the format `{\"tool_call_result\": ...}`, treat it as the successful output of your previous tool request."

### 3.3 异步性说明
在这种模式下，**没有全自动的 Server-Side Loop**。模型每输出一个工具调用，HTTP 请求就结束了。下一次请求（带结果）是一个全新的请求，通过 `messages` 数组维持状态。
