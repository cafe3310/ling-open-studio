# 设计 - 以助手为中心的架构重构 (Assistant-Centric Architecture)

## 1. 概述 (Overview)
随着项目能力的扩展（从简单聊天到复杂的网页生成），扁平化的代码结构已难以维护。为了实现高内聚、易扩展的多助手系统，本项目参考 `ling-model-judge` 的设计理念，将逻辑按助手（Assistant）维度进行垂直切分。

## 2. 目录结构方案

### 2.1 `assistants/` (助手核心逻辑)
根目录下的 `assistants/` 包含所有业务助手的完整闭环。

```text
assistants/
├── registry.ts             # 助手注册表：根据 mode 映射到具体的 Graph
├── general-chat/           # 【通用对话助手】 (Mode: chat)
│   ├── graph.ts            # LangGraph 定义
│   └── prompts.ts          # 角色人格定义
├── web-architect/          # 【网页生成助手】 (Mode: web-gen)
│   ├── initial-gen.ts      # 首次生成 Graph
│   ├── refine-gen.ts       # 后续修改 Graph
│   ├── tools.ts            # 助手专用工具 (如预览刷新)
│   └── lib/                # 私有工具函数
└── naming/                 # 【自动命名助手】
    └── graph.ts            # 命名生成 Graph
```

### 2.2 `lib/` (通用基础设施)
根目录下的 `lib/` 存放跨助手的共享能力。

```text
lib/
├── vfs/                    # 虚拟文件系统 (核心层)
├── tools/                  # 工具链助手库
│   ├── factory.ts          # Tool Calling 定义与解析 Helper
│   └── vfs-tools.ts        # 封装好的读写文件共享工具
├── assistant-utils/        # 助手相关的通用工具
│   └── reasoning-splitter.ts # 推理过程解析逻辑
├── store.ts                # 前端状态 (Zustand)
├── utils.ts                # 基础工具类
└── model.ts                # 模型工厂
```

## 3. 核心设计模式

### 3.1 动态路由 (Dynamic Routing)
在 `/api/chat` 中，不再硬编码调用某个 Graph，而是通过 `registry.ts` 实现动态调度：
```typescript
import { assistantRegistry } from '@/assistants/registry';

// 在 Route 处理逻辑中
const mode = config.mode || 'chat';
const assistant = assistantRegistry.get(mode);
const result = await assistant.graph.invoke(...);
```

### 3.2 工具注入 (Tool Injection)
每个助手可以根据自己的需求，从 `lib/tools` 中挑选通用工具，并结合自己在 `assistants/<name>/tools.ts` 中定义的私有工具，组成最终的 `tools` 列表。

## 4. 迁移计划
1.  **创建目录**: 建立 `assistants/` 和 `lib/assistant-utils/` 等结构。
2.  **迁移代码**: 将 `app/lib/assistants/` 中的内容按功能移入新位置。
3.  **修复导入**: 全局更新 `@/app/lib/...` 为新路径。
4.  **删除冗余**: 清理空目录。
