# 2026-02-07-16-30-系统设计-ModelWeb网页生成架构

## 1. 背景与目标
用户希望在 "Model Web" Tab 实现一个端到端的网页生成功能。该功能不依赖后端构建服务，完全在浏览器端运行。

**核心流程**:
1.  **输入**: 用户在空白工作区输入需求。
2.  **生成**: 触发 "Initial Generation" Graph (LangGraph)，经历 `需求详细化` -> `风格设计` -> `编码` -> `修复` 四个阶段。
3.  **存储**: 生成产物写入浏览器端 VFS (`/workspace/webapp/<task_id>/`)。
4.  **预览**: 右侧预览区通过 iframe 实时渲染 VFS 内容。
5.  **迭代**: 用户基于预览结果进行对话，模型直接修改 VFS 文件进行订正。

## 2. 技术栈选型 (浏览器端运行方案)

为了实现“不动用服务端资源”且“即时预览”，我们需要选择一种无需构建步骤（No-Build）或支持浏览器端构建的方案。

### 方案 A: 单文件静态网页 + Tailwind CDN (推荐 Phase 1)
这是最稳健、成功率最高的方案。
*   **技术栈**: HTML5 + Vanilla JS + Tailwind CSS (Script Tag)。
*   **原理**: Agent 生成一个包含 `<script src="https://cdn.tailwindcss.com"></script>` 的 HTML 文件。
*   **优点**: 
    *   零构建成本，写入 VFS 即可预览。
    *   LLM 对 HTML/CSS 的生成能力最强，出错率低。
    *   Tailwind CDN 支持即时编译 utility classes。
*   **缺点**: 无法使用复杂的 npm 包，代码复用性较差。

### 方案 B: React + Babel Standalone + Tailwind
支持写 JSX，但性能较差，且 LLM 容易混淆 ESM/CJS 导入语法。
*   **技术栈**: React (UMD) + Babel Standalone (浏览器内编译 JSX)。
*   **原理**: 在 HTML 中引入 React 库和 Babel，将代码写在 `<script type="text/babel">` 中。
*   **风险**: 浏览器内编译慢，且 Import/Export 语法处理非常麻烦（需要 shim）。

### 结论
**Phase 1 采用方案 A**。它能最快地验证“VFS -> Preview”的链路，且 Tailwind 保证了视觉效果足够现代。后续可探索基于 `WebContainer` 的方案 C 来支持完整的 Node.js 开发环境。

## 3. Agent Graph 设计 (LangGraph)

我们将定义一个名为 `WebGenGraph` 的状态图。

### 3.1 状态定义 (State)
```typescript
interface WebGenState {
  messages: BaseMessage[];
  taskId: string;          // 本次生成的目录 ID
  requirements: string;    // 详细化的需求文档
  design_spec: string;     // 视觉设计规范 (配色、字体、布局)
  file_paths: string[];    // 生成的文件列表
  iteration: number;       // 当前迭代轮次
}
```

### 3.2 节点流转 (Nodes)

1.  **Requirement Analyst (需求分析师)**
    *   **输入**: 用户模糊的 Prompt。
    *   **职责**: 补全细节（功能列表、交互逻辑）。
    *   **输出**: 更新 `requirements` 字段。

2.  **UI/UX Designer (设计师)**
    *   **输入**: `requirements`。
    *   **职责**: 定义配色方案（Tailwind Colors）、字体、布局结构。
    *   **输出**: 更新 `design_spec` 字段。

3.  **Fullstack Engineer (工程师)**
    *   **输入**: `requirements` + `design_spec`。
    *   **职责**: 编写 HTML/CSS/JS 代码。
    *   **操作**: 调用 `write_file` Tool 将代码写入 VFS (`/workspace/webapp/<id>/index.html`)。
    *   **输出**: 更新 `file_paths`。

4.  **QA Engineer (测试与修复)**
    *   **输入**: 生成的代码。
    *   **职责**: 静态检查（如检查 HTML 闭合、Tailwind 类名是否存在）。
    *   **操作**: 如果发现问题，调用 `write_file` 修正；否则通过。

### 3.3 交互模式
*   **Mode 1: Initial Gen (初始生成)**: 按顺序执行 `Analyst -> Designer -> Engineer -> QA`。
*   **Mode 2: Chat Refine (对话迭代)**: 用户后续的反馈直接路由到 `Engineer` 或 `Designer` 节点，进行增量修改。

## 4. VFS 目录结构规划

为了支持多版本和回滚，建议结构如下：

```text
/workspace/webapp/
    ├── <uuid-1>/              # 任务 ID
    │   ├── index.html         # 主入口
    │   ├── style.css          # (可选)
    │   ├── app.js             # (可选)
    │   └── metadata.json      # 存储 prompt, timestamp
    └── <uuid-2>/
```

## 5. UI 界面设计 (Model Web Tab)

界面将分为左右两栏：

*   **左侧 (Chat)**: 
    *   标准的 Chat 界面。
    *   显示 Graph 的执行状态（例如：正在分析需求... 正在设计...）。
    *   显示生成的工件链接。
*   **右侧 (Preview)**:
    *   **Iframe**: `src` 指向一个 Blob URL 或 Data URL（由 VFS 内容动态生成）。
    *   **Address Bar**: 模拟浏览器地址栏，显示当前 VFS 路径。
    *   **Refresh Btn**: 强制重新从 VFS 读取渲染。
    *   **Tech Stack**: 显示当前使用的技术栈标签 (HTML/Tailwind)。

## 6. 开发计划

1.  **Step 1: 准备 VFS Tool**: 封装 `write_vfs_file`, `read_vfs_file` 为 LangChain Tools。
2.  **Step 2: 实现 WebGenGraph**: 定义上述 StateGraph 和 Node Prompts。
3.  **Step 3: 实现 Preview 组件**: 监听 VFS 变更，通过 `srcDoc` 渲染 HTML。
4.  **Step 4: 集成**: 将 Graph 和 Preview 组件整合进 Model Web Tab。
